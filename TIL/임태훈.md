## 250113 TIL 
### 약물 복용 다이어리(Pillme)
- 타겟층
    - 고령층 (65세 이상)
    - 만성질환자
    - 보호자 및 간병인
- 메인 기능
    - OCR을 이용하여 처방전 및 처방 봉투에서 약물 정보 기록
    - 정확한 약물 정보가 존재하지 않을 시, 관련 추천 단어 또는 검색을 통해 추가
    - 추가된 약물을 캘린더 형식에 복용 기간을 표시 및 주기적인 알람 설정을 통해 사용자에게 알림
    - 약물 성분을 분석하여 정보 제공
- 기대 효과
    - 복용 기록을 기반으로 부작용 및 중복 복용 예방
    - 복용 기록 데이터를 통해 의료진에게 보다 명확한 데이터 제공
    - 복용 알림 기능으로 복약 관리 지원
#
### 본인 취미 관심사 관련 주제 빌드업
- 술
    - 본인이 마신 술에 대한 향, 맛 등을 기록하는 노트
    - 기본적인 칵테일 레시피 공유
    - 각자의 커스텀 칵테일 레시피 공유
    - 셀프 양조를 체험하고 싶은 이들을 위한 경험자의 레시피 및 노하우 공유
    - 전통주 브랜드 소개
    
- 낚시
    - 본인이 잡은 물고기를 기록하는 2D 어항 서비스
    - 기록을 기반으로 유저끼리 진행하는 월별 명예의 전당 서비스
    - 본인이 방문한 낚시 포인트 체크하는 전국 지도 서비스
#
### 폭포수 모델
- 프로젝트의 각 단계가 순차적으로 수행, 이전 단계로 돌아가지 않음.
- 변화에 대한 대처 능력이 떨어짐.

### 에자일 방식
- 유연한 프로젝트 관리가 가능함.
    -> 지라는 에자일 방식 보드판의 역할을 함.
- 큰 프로젝트를 작은 단위로 분할하여 진행
- 짧은 스프린트 단위로 개발하며 지속적으로 피드백 반영
#
### 지라
업무와 일정을 계획, 관리하기 위해 사용
에픽 >> 스토리 >> 데스크 순
- 에픽
	- 완료하기까지 여러 번의 스프린트가 요구되는 가장 큰 업무 단위
	- ex) 사용자 계정 및 인증 시스템 구현, 관리자 대시보드 개발, API 통합, 외부서비스 연동
- 스토리
	- 사용자 관점에서의 요구사항. 또는 구체적인 기능을 나타내는 작업 단위
	- ex) 로그인 기능, 상품 목록 조회
- 태스크(하위이슈)
	- 스토리를 완료하기 위해 개발자가 작업해야 하는 단위 작업
	- ex) 토큰 갱신 로직, Oauth 연동 검색
- 백로그
	- 완료되지 않은 작업 항목들의 목록
	- 언제든지 이슈를 작성해서 올리면 됨(상시 추가 가능)
	- 우선순위로 정렬되어 있어야 함(Product Owner의 역할)
- 스토리 포인트
	- 싸피
    	- 1시간의 업무량을 기준으로 1점으로 표현
    	- 단순해서 포인트를 선정하기 쉽지만, 이 경우 학습으로 인한 시간도 업무량으로 표현되어 제대로 된 업무량이 추산되지 않을 수 있음.
	- 현업
    	- 작업에 들어가는 노력의 양을 임의로 추정하여 포인트 분배
    	-> 두 가지 방법 모두 익숙해질 것.
- 스프린트 로그
	- 특정 스프린트 동안 수행하기로 약속한 작업 항목들의 목록
	- 팀의 작업 역량을 고려해 백로그에서 우선순위가 높은 항목들을 차례대로 스프린트 로그로 이동
- 스크럼 보드
	- 스프린트 동안 작업 항목의 진행 상황을 시각적으로 보여주는 보드
	- 사용 목적: 팀의 진행상황을 누구나 투명하게 볼 수 있도록 공유
	- 진행 중에는 팀원 1명당 1개
	- 리뷰에 올린 기능은 팀원이 함께 리뷰
#
## 250114 TIL 
### Pill me 아이디어 구체화
1. 기능 구조도 설계
- 투약기록
	- 처방전/약봉투 인식
		- 카메라 기능 -> OCR 기능
		- 수동 텍스트 대조 -> 투약량/일 확인
		- 투약 정보 삽입
		- 약 정보 - API
	- 사용자 상태 등록
		- 금지된 행위 표시
		- 복용 중 약물 표시 -> 개별 약물 상세내용
- 캘린더
	- 달력
		- 약물 복용 기간
		- 과거 복용 내역
	- 리스트
		- 약물 복용 기간
		- 과거 복용 내역
		- 약물 정보 제공
	- 사용자 전환 기능
		- 전환에 따른 전기능 상태변경
- 커뮤니티
	- 카테고리
		- 즐겨찾기
		- 카테고리 추가
	- 게시글
		- 이미지 삽입
		- 태그 추가
		- 글 작성
		- 스크랩
- 마이페이지
	- 회원가입
		- 이메일 회원가입
		- 구글 회원가입
		- 네이버 회원가입
	- 로그인
		- 이메일 로그인
		- 구글 로그인
		- 네이버 로그인
	- 개인 정보 관리
		- 투약 관리자 관리 -> 팔로우/언팔로우
		- 개인 정보 관리
	- 로그아웃
		-로그아웃
- 알림
	- 본인
		- 복용 시간 설정 -> 투약 알림 관리
	- 관리자
		- 투약 알림 관리
	- 피관리자
		- 투약 알림 관리
2. OCR 기능 정리
3. 로그인 기능 정리
4. 인원 추가 기능 정리
- 로컬
	- 개인 사용자 로컬에서 임의 추가
		- 자유도 높음
		- 타인 승인 불필요
- 글로벌
	- 개인 사용자 팔로잉 팔로우 기능
		- 관리자/피관리자 관계 설정
		- 관리 관계는 유동적으로 설정 가능하고 둘 다 갑을관계 형성 가능
	- 팔로잉 팔로우 기능에 대한 방식 논의
		- 알림 전체 허용 / 비허용 방식
		- 개인별 알림 허용 승인 방식
		- 단방향으로 픽스
#
## 250115 TIL
### GIT 강의
#### GIT이 필수인 이유?
    1. 이력관리 - 모든 변경사항은 기록됨
    2. 분산 버전 관리 - 로컬 저장소와 원격 저장소를 활용한 협업
    3. 협업 효율성 - 여러 사람이 동시에 충돌없이 작업가능
#### 기본 개념
    1. 저장소 - 코드의 과거와 현재를 담은 공간
    2. 커밋 - 변화의 순간을 포착하는 스냅샷
    3. 브랜치 - 아이디어를 실험하고 구현하는 독립적인 공간
    4. 병합 - 아이디어 결과물을 프로젝트에 반영
#### Git 사용 유의점
    1. 커밋 메시지 작성 규칙 - 명확하고 일관적인 메시지 작성이 중요
    2. 브랜치 전략 - 명확한 브랜치 구조는 작업 속도를 높이고 충돌을 최소화
#### 커밋 시 고려해야하는 2가지
    1. 시점 - 논리적으로 완결된 작업 단위
    2. 횟수 - 작은 단위로 자주 커밋
#### 커밋 구성 요소
    - 커밋 ID
    - 작성자 정보
    - 커밋 메시지
#
### 아이디어 피드백
#### 메인 기능 약 정보 기록 자동화 관련
    1. 단순 AI프롬프팅 이용은 규모가 작아보임.
       - 전처리 과정을 확실하게 가져간다면 OK
    2. OCR 이용
       - 알약 데이터를 DB에 넣어 인식된 글자와 비교 또는 검색 쿼리 이용
         - 검색 로직 최적화 필요
         - Elastic Search 추천
       - 병원, 약국 이름 인식의 경우, 정해진 형식이 존재할 것.
         - 사용자의 위치 기반으로 구역을 정해놓고 전국으로 확장하는 방식 권장
    3. 데이터를 모두 처리한 후, 사용자 컨펌 필수
#### TEST 관련
    1. AI프롬프팅, OCR 성능을 100개의 테스트 케이스를 통해 비교해 선택하려는 테스트는 괜찮을지
       - Test 과정은 필수적.
       - 100개는 적고 1000~10000개 정도를 이용
       - 테스트 케이스의 경우, 회전하거나 각도를 조절하여 생성
       - 경량화해서 이용하는 방식도 고려
#### API가 아닌 파일을 통해 데이터베이스에 저장 관련
    1. 스케줄러를 이용해서 DB에 저장
       - 컬럼에 몇 일자에 저장했는지를 넣어 비교하여 관리
    2. 업데이트 중 서비스가 중단시킬 것인지, 지속적으로 이용 가능하게 할지 고려
#### 웹앱 개발에서 PWA 관련
    1. 당위성 측면에서 비추천 -> 카메라 이용에서 불편이 존재할 수 있음.
       - native 또는 hybrid 추천
#### 알림 기능 FCM 및 Kafka 관련
    1. 어떤 형식의 알림을 보내는지를 고려할 것
    2. Kafka는 알림이 정확한 시간(1초 단위)의 오차가 없어야 할 때.
    3. 왜 이 기술들을 사용하는지 학습해볼 것
#### 전반적 피드백
    1. 한 기능에 매몰되지 말고 결과를 정해놓고 쉬운 방법으로 구현 후, 고도화 할 생각을 할 것.
    2. 한 단계씩 맡아 최적화. 단계별로 어떻게 성능을 올릴지 생각해볼 것.
    3. 플로우와 기능에 대한 결과가 중요.
    4. 개인 정보의 경우, 암호화 필요.
#
### 팀원 간 아이디어 기획 이해 일치
- 피드백 진행 후, 2시간 가량 피드백과 기획 전체를 팀원 간 일치시키는 과정을 거침.
- 아이디어를 일치시키는 과정에서 대략적인 플로우를 이용.
- 플로우를 기반으로 UseCase 작성.
#
### Jira 사용
- 코치님께 에픽, 스토리, 테스크 범위 및 예시에 대한 자문.
- 에픽은 1~2주의 큰 단위
- 스토리는 사용자 입장에서의 단위
- 테스크는 개발자 입장에서의 단위
- 팀원들과 진행한 기획을 정리하며 향후 수행할 작업을 일부 작성
#
## 250116 TIL
### 요구사항 명세서
- 팀원들과 프로젝트의 기능에 대한 의견 통합을 위해 요구사항 명세서 작성
- 백엔드 담당의 역할을 분배
- 피부양자 등록은 QR과 초대 링크를 통해 등록 할 수 있어야 한다.
   - 전화번호의 경우, 번호가 변경될 경우의 문제를 우려함.
   - 이메일의 경우, 피보호자(노인)의 이메일을 알기 어려울 것임.

| 기능 | 기능적 요구사항 | 비기능적 요구사항 | 비고 | 도메인 | 담당 |
|-----|--------------|---------------|------|-------|-----|
| 회원가입 | - 회원이 회원가입을 할 때 동일한 아이디가 없는 지 확인해야 한다. | - 회원이 회원 가입을 전송했을 때 5초 이내에 끝나야 한다. <br>- 사용자 정보를 암호화 해야 한다.<br>- 비밀번호는 최소 12자 이상, 대문자/소문자/숫자/특수문자 포함<br>- 회원 탈퇴 시 SOFT DELETE로 한다. | - 이메일 (본인확인용, 이메일 인증) <br>- 비밀번호<br>- 전화번호<br>- 이름 | auth | 정예영 |
| 로그인 | - 사용자가 무조건 로그인을 하도록 한다. | - 로그인 편의성을 위해서 소셜 로그인 기능을 구현한다.<br>- 구현 방법: OAuth, 자체 이메일 로그인 | - OAuth2 사용<br>- 사용자로부터 이메일을 조회할 수 있는 OAuth 인증 수단 개발 | auth | 정예영 |
| 아이디(이메일) / 비밀번호 찾기 | - 자체 인증 서비스에서 사용자가 아이디(이메일) 또는 비밀번호를 분실했을 경우 찾을 수 있도록 한다. | - 비밀번호 찾기 때 이메일 전송은 비동기 처리로 해야 한다. | | auth | 정예영 |
| 복용 약물 등록 | - 사용자의 복용 약물 정보 관련 사진을 통해서 약물 정보를 등록하도록 한다. <br>- 사용자가 직접 등록할 수 있도록 한다.<br>- 사용자가 방문한 병원을 등록할 수 있도록 한다.<br>- 부양자를 추가했을 경우 부양자의 복용 약물을 등록할 수 있도록 한다. |- 사진을 통해서 등록 하는 경우 OCR과 AI 기능을 활용하여 개발하여야 한다.<br>- 등록한 사진으로부터 가져온 텍스트의 부정확함을 보완하기 위해 사용자 확인 및 수정 필요 | - 복용 약물 리스트 PK를 다른 곳에 FK로 사용할 때 암호화 하는 정책을 나중에 논의 해봐야 한다. <br>- 엘라스틱 서치(연관 검색어로 수동 등록이 용이하게 함) | medicine | 오세학
| 복용 약물 알림 | - 사용자가 설정한 시간에 맞춰서 복약 알림을 보낸다. <br>- 부양자는 피부양자의 약물 복약 알림을 설정할 수 있어야 한다.<br>- 알림 설정은 1시간 단위로 설정해야 한다. | - 플랫폼 제약 없이 사용해야 하기 때문에 FCM과 Kafka를 활용하여 개발해야 한다.<br>- 알림은 설정된 시간 +- 1분에 사용자에게 도착해야 한다. | | notification | 임태훈
| 복용 약물 관리 | - 사용자는 자신이 복용한 약물을 체크 및 체크 해제할 수 있어야 한다.<br>- 피부양자의 복용 약물을 관리할 수 있어야 한다.<br>- 피부양자는 부양자가 추가한 약물을 삭제할 수 없다.<br>- 피부양자가 금일 복용한 약물 기록을 부양자는 조회할 수 있다. | - 데이터베이스에 복용 약물 사실 컬럼을 특정 시간에 복용 약물 기록 테이블에 삽입하고 초기화 해야 한다.<br>- 피부양자의 약물 복용 사실을 부양자는 실시간으로 확인해야 한다. | - 폴링 방식으로 구현해야 할 지, 아니면 직접 새로고침으로 진행해야 할 지 선택해야 한다.(컨설팅 받기)<br>- FE 개발자에게 폴링 방식과 오프라인 방식을 분리하도록 하자. | medicine, log | 오세학
| 부양자 등록 | - 사용자는 자신이 부양해야 하는 개체의 약물 복용을 관리할 수 있어야 한다. | - 등록의 용이성을 위해서 초대 코드 및 QR 코드로 피 부양자를 등록해야 한다. | auth 도메인이 개발된 다음에 착수 | management | 
| 채팅 | - 관리자 & 피부양자 간 채팅 | - 텍스트 및 이미지 전송이 가능해야 한다. | | chat | 조승근
| 마이페이지 | - 사용자 정보 수정<br>- 피부양자 등록은 QR과 초대 링크를 통해 등록 할 수 있어야 한다. | | - auth와 user 도메인이 개발된 다음에 착수해야 함 | user
| 커뮤니티 | - 건강 향상 증진을 위한 챌린지 형식의 커뮤니티 기능을 해야 한다. | | | community
| 전체 회원 관리 | - 관리자는 전체 회원의 부양, 피부양 여부를 관리할 수 있어야 한다. | | | admin
#
### 백엔드 코드 컨벤션
    - 패키지 구조 컨벤션 정의
    - Commit 컨벤션 정의
    - Branch 전략 정의
    - 템플릿 (기능, 버그, PR 신청) 정의
    - DTO 구조 정의
    - 응답 규칙 정의
#
## 250117 TIL
### Jira 사용
    1. 팀원들과 에픽/스토리/테스크를 세분화하는 방법 토의 및 설계
    2. 설계된 방안으로 Jira 수정
    3. 각 이슈에 대한 스토리 포인트 설정 및 스프린트 생성
#
### ERD 설계
    1. ERD Cloud를 이용하여 ERD 설계 진행
    2. 약물, 날짜별 복용 관리, 복용 기간 관리 테이블을 설계 시, 스케줄러를 사용하는 경우와 사용하지 않는 경우에 대해 데이터 관리 및 성능 토의
    3. 사용하지 않는 방식으로 설계
#
## 250120 TIL
### Git
    Rebase란?
       - 브랜치의 기반(base)을 다른 커밋으로 변경하는 것
       - conflict가 처음 발생한 이후의 커밋마다 충돌을 해결해야 함
       - 히스토리를 건드는 명령어이므로 이미 push된 내용을 reabse 할 경우, 팀원 코드와 꼬일 수 있음
       - 따라서, 로컬 브랜치에서만 rebase 사용
       - rebase된 내용을 원격 repo에 push할 땐, 옵션 사용에 주의
         - --force(x), --force-with-lease(o)
       - rebase가 원격 repo에 반영되었다면, 팀원들은 원격 repo의 내용을 로컬에 반영 후 작업 수행
         - git fetch origin, git reset --hard origin/브랜치명
#   
### 백엔드 기술 공유
    1. 로그인/회원가입
       - 회원가입 시 전화번호를 저장해야하는데 네이버, 카카오는 OAuth를 사용하게 되면 정보를 받아올 수 있으나 구글은 불러올 수 없음.
       - 전화번호 인증 작업 -> 메시지로 인증
       - 오프라인 시 알림을 받을 수 없으므로 로그인을 길게 유지시킨다면 보안에 취약할 우려가 있음.
    2. FCM
       - PWA는 앱 환경이 아닌 웹 환경과 같기 때문에 FCM 로직 자체는 유사함.
       - 오프라인/자동 로그아웃된 환경에서 알림이 가능한지? -> 디바이스에 저장한다면 가능.
       하지만 이 경우, 다른 플랫폼에서 알림 설정을 변경 할 경우 반영하기가 어려움.
       - 여러 기기에서 한 계정을 사용하는 경우/한 기기에서 여러 아이디를 사용하는 경우를 고려하면 기존의 USER테이블에 저장하는 방식이 아닌 FCM 토큰을 관리하는 테이블을 분리하여 관리해야함.
    3. 약 정보 저장
       - 엘라스틱 서치를 통해 연관 검색어/오타 정정 기능/인기 검색어 기능 구현 가능
    4. 채팅
       - AWS 서버가 1개 주어지기 때문에 Kafka 전용 서버를 둘 수 없기 때문에 의미가 퇴색될 수 있음.
#
### PWA
    - PWA는 2개의 다른 운영 체제를 이어주는 역할.
    - service worker가 html, css, js를 저장 및 관리.
      - 따라서 저장 및 관리되는 코드에는 민감한 정보가 존재하면 안됨.
    - service worker는 device에 존재하는 것이고 필요할 때마다 활성화되는 것.
    - TCP/UDP를 직접 생성하고 제어하는게 불가능한 이유는 브라우저 샌드박스 보안 정책 때문.
      - 샌드박스 -> 보안을 위해 제한된 격리 실행 환경을 따로 줘서 기능들이 제한됨.
#
## 250121 TIL
### 데이터베이스 인덱스
#### 기본 원리
- 테이블의 특정 컬럼에 대해 정렬된 형태로 별도 저장됩니다
- 컬럼의 값과 해당 레코드의 위치 정보를 가지고 있습니다
- B+Tree 구조가 가장 일반적으로 사용됩니다

#### 장점
- 검색 속도가 매우 빨라집니다
- ORDER BY 등의 정렬 연산을 빠르게 처리할 수 있습니다
- 특정 컬럼의 유일성을 보장할 수 있습니다 (Unique Index)

#### 단점
- 추가적인 저장 공간이 필요합니다
- INSERT, UPDATE, DELETE 시 인덱스도 함께 수정해야 하므로 성능 저하가 발생합니다
- 잘못 설계된 인덱스는 오히려 성능을 저하시킬 수 있습니다

#### 인덱스 종류
- 단일 인덱스: 하나의 컬럼으로 구성
- 복합 인덱스: 여러 컬럼을 조합하여 구성
- 클러스터드 인덱스: 데이터가 물리적으로 정렬되어 저장
- 비클러스터드 인덱스: 데이터와 별도로 인덱스만 정렬

#### 인덱스 사용이 효과적인 경우
- WHERE 절에서 자주 사용되는 컬럼
- JOIN에 자주 사용되는 컬럼
- 데이터의 선택도(Selectivity)가 높은 컬럼
- ORDER BY나 GROUP BY에 자주 사용되는 컬럼

### 인덱스가 존재할 때와 존재하지 않을 때의 성능 차이

#### 테이블 전체 검색 (Full Table Scan)

- 인덱스 없음: O(N) - 모든 레코드를 순차적으로 검색
- 1백만 건 데이터 기준: 약 2-3초 소요

#### 인덱스를 활용한 검색 (Index Scan)
- 인덱스 있음: O(log N) - B+Tree 구조 활용
- 1백만 건 데이터 기준: 약 0.1초 미만 소요

#### 인덱스가 오히려 성능을 저하시키는 경우
- 대량의 데이터를 조회하는 경우
- 데이터 입력/수정이 빈번한 경우

일반적으로 10-15% 미만의 데이터를 조회하는 경우 인덱스가 효과적이며, 그 이상의 데이터를 조회할 때는 전체 테이블 검색이 더 효율적일 수 있음.

### 팀 전체 회의
    * 프론트에서 완성한 피그마와 백엔드에서 작성한 요구사항 명세서를 통해 의견 통합 진행
    * 기능 구현 부분은 기능 완성 후 단계적으로 확장하는 방식으로 채택
    * 피그마를 확인하며 기능을 함께 고려했을 때, 팀원 간 기능에 대한 의견 통일

### Jira 번다운 차트에 영향을 주는 것
    - 스프린트 작업량 변경
        이슈의 스토리 포인트 수정
        이슈의 예상 시간 수정

    - 스프린트 범위 변경
        스프린트에 이슈 추가
        스프린트에서 이슈 제거

    - 이슈 상태 변경
        To Do → In Progress
        In Progress → Done
        Done → In Progress 등
#
## 250122 TIL
### 면접단골 질문
- SOLID
  1. Single Responsibility Principle (단일 책임 원칙)
    - 한 클래스는 하나의 책임만 가져야 한다.
  2. Open-Closed Principle (개방-폐쇄 원칙)
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    - 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 한다.
  3. Liskov Substitution Principle (리스코프 치환 원칙)
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 정확성을 깨뜨리지 않아야 한다.
    - 상속은 올바른 계층 구조에서만 사용되어야 한다.
  4. Interface Segregation Principle (인터페이스 분리 원칙)
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
    - 하나의 큰 인터페이스보다 여러 개의 작은 인터페이스가 좋다.
  5. Dependency Inversion Principle (의존성 역전 원칙)
    - 추상화는 세부 사항에 의존하지 않아야 한다. 세부 사항이 추상화에 의존해야 한다.
- D(Do not)R(Repeat)Y(Yourself) : 중복을 피해라, 코드 중복 피하기/자동화
- K(Keep)I(It)S(Simple)S(Stupid) : 너무 정교한 것에 집착하지마라. 간단하고 멍청해보이는 것으로 접근
- Y(You)A(Ain't)G(Gonna)N(Need)I(It) : 오버 엔지니어링 하지마라

### ERD 재작성
    * 기존의 약물 복용 관리 테이블 구조는 미래의 불필요한 비어있는 row들이 생성될 수 있음.
      따라서, 복약 관리 테이블에 약을 먹었는지 체크한 내역을 히스토리 테이블로 스케쥴러를 통해 저장하기로 변경
    * 알림을 수신했는지 여부를 확인하기 위해 fcm 응답 대한 테이블 생성
    * 의존관계를 요청했을 때 동의 여부와 부양자의 약물 추가/삭제를 동의하는지에 대한 알림을 위해 테이블 생성

### Jira 구조 변경
  - 기존의 1주 단위 에픽 설정, 사용자의 관점에서의 스토리, 개발자 관점에서의 하위 테스크는 스토리 포인트를 반영하지 못하기 때문에 구조 변경
  - 기능 별로 에픽을 선정하고 스토리는 팀원 각자의 업무로 변경

### FCM
#### FCM이란?

- 무료로 메시지를 전송할 수 있는 교차 플랫폼 메시징 솔루션
- Google의 클라우드 메세징 서비스로, 쉽게 실시간 푸시메세지를 구현할 수 있음.
- FCM 토큰이라는 것으로 사용자를 식별할 수 있으며, 이 토큰만 가지고 있으면 손쉽게 푸시메세지를 발행 할 수 있음.
- FCM 서버는 Google이 관리하고 있으므로, 구현이 복잡하지 않음.

#### 왜 사용하는가?

- FCM을 이용하면 플랫폼에 종속되지 않고 푸쉬 메시지를 전송할 수 있음.
- iOS, Android, Web 각 플랫폼에서 푸쉬 메시지를 보내려면 각 플랫폼 환경별로 개발해야하는 불편함이 있는데 이를 하나로 통합하는 솔루션임.

#### 클라우드 메시징 서비스를 사용하면 어떤 이점이 있는가?

- 서버를 경유해서 실시간으로 푸쉬 메시지를 받으려면 사용자는 항상 서버에 접속해있어야하는데 이는 사용자 기기의 배터리 및 네트워크 리소스를 크게 낭비한다.
- 클라우드 메시징 서버를 중간에 둠으로써, 사용자는 낮은 배터리와 네트워크의 사용만으로도 메세지를 실시간으로 송수신 처리를 할 수 있다.
- 위와 같은 이유로 대부분의 어플리케이션 서비스들은 클라우드 메시징 서버를 경유해서, 실시간으로 유저들에게 메시지를 전송해주고 있다.

#### 주요 기능

1. **메시지 전송 기능**
    - 알림 메시지: 사용자에게 직접 보이는 일반적인 푸시 알림
    - 데이터 메시지: 앱이 직접 처리하는 데이터 형태의 메시지
2. **메시지 타겟팅**
    - 개별 기기로 전송
    - 특정 기기 그룹으로 전송
    - 특정 주제를 구독한 모든 기기로 전송
3. **양방향 통신**
    - 서버에서 클라이언트로의 통신
    - 클라이언트에서 서버로의 통신이 모두 가능

#### 시스템 구성

1. **서버 환경**
    - FCM 연결 서버
    - 애플리케이션 서버 (HTTP/XMPP 기반)
    - 클라우드 기능
2. **클라이언트 환경**
    - iOS, Android, 웹 애플리케이션

#### 작동 방식

1. **기기 등록 단계**
    - 앱 설치 시 FCM 서버에 등록
    - 고유한 FCM 토큰 발급 받음
2. **메시지 전송 과정**
    - 서버에서 메시지 생성
    - FCM 백엔드에서 메시지 처리
    - 플랫폼별 전송 시스템을 통해 메시지 전달
    - 사용자 기기에서 메시지 수신
3. **분석 기능**
    - Google 애널리틱스와 통합되어 있어 메시지 효과 측정 가능
    - 사용자 반응 및 참여도 추적 가능
