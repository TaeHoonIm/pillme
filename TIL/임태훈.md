## 250113 TIL 
### 약물 복용 다이어리(Pillme)
- 타겟층
    - 고령층 (65세 이상)
    - 만성질환자
    - 보호자 및 간병인
- 메인 기능
    - OCR을 이용하여 처방전 및 처방 봉투에서 약물 정보 기록
    - 정확한 약물 정보가 존재하지 않을 시, 관련 추천 단어 또는 검색을 통해 추가
    - 추가된 약물을 캘린더 형식에 복용 기간을 표시 및 주기적인 알람 설정을 통해 사용자에게 알림
    - 약물 성분을 분석하여 정보 제공
- 기대 효과
    - 복용 기록을 기반으로 부작용 및 중복 복용 예방
    - 복용 기록 데이터를 통해 의료진에게 보다 명확한 데이터 제공
    - 복용 알림 기능으로 복약 관리 지원
#
### 본인 취미 관심사 관련 주제 빌드업
- 술
    - 본인이 마신 술에 대한 향, 맛 등을 기록하는 노트
    - 기본적인 칵테일 레시피 공유
    - 각자의 커스텀 칵테일 레시피 공유
    - 셀프 양조를 체험하고 싶은 이들을 위한 경험자의 레시피 및 노하우 공유
    - 전통주 브랜드 소개
    
- 낚시
    - 본인이 잡은 물고기를 기록하는 2D 어항 서비스
    - 기록을 기반으로 유저끼리 진행하는 월별 명예의 전당 서비스
    - 본인이 방문한 낚시 포인트 체크하는 전국 지도 서비스
#
### 폭포수 모델
- 프로젝트의 각 단계가 순차적으로 수행, 이전 단계로 돌아가지 않음.
- 변화에 대한 대처 능력이 떨어짐.

### 에자일 방식
- 유연한 프로젝트 관리가 가능함.
    -> 지라는 에자일 방식 보드판의 역할을 함.
- 큰 프로젝트를 작은 단위로 분할하여 진행
- 짧은 스프린트 단위로 개발하며 지속적으로 피드백 반영
#
### 지라
업무와 일정을 계획, 관리하기 위해 사용
에픽 >> 스토리 >> 데스크 순
- 에픽
	- 완료하기까지 여러 번의 스프린트가 요구되는 가장 큰 업무 단위
	- ex) 사용자 계정 및 인증 시스템 구현, 관리자 대시보드 개발, API 통합, 외부서비스 연동
- 스토리
	- 사용자 관점에서의 요구사항. 또는 구체적인 기능을 나타내는 작업 단위
	- ex) 로그인 기능, 상품 목록 조회
- 태스크(하위이슈)
	- 스토리를 완료하기 위해 개발자가 작업해야 하는 단위 작업
	- ex) 토큰 갱신 로직, Oauth 연동 검색
- 백로그
	- 완료되지 않은 작업 항목들의 목록
	- 언제든지 이슈를 작성해서 올리면 됨(상시 추가 가능)
	- 우선순위로 정렬되어 있어야 함(Product Owner의 역할)
- 스토리 포인트
	- 싸피
    	- 1시간의 업무량을 기준으로 1점으로 표현
    	- 단순해서 포인트를 선정하기 쉽지만, 이 경우 학습으로 인한 시간도 업무량으로 표현되어 제대로 된 업무량이 추산되지 않을 수 있음.
	- 현업
    	- 작업에 들어가는 노력의 양을 임의로 추정하여 포인트 분배
    	-> 두 가지 방법 모두 익숙해질 것.
- 스프린트 로그
	- 특정 스프린트 동안 수행하기로 약속한 작업 항목들의 목록
	- 팀의 작업 역량을 고려해 백로그에서 우선순위가 높은 항목들을 차례대로 스프린트 로그로 이동
- 스크럼 보드
	- 스프린트 동안 작업 항목의 진행 상황을 시각적으로 보여주는 보드
	- 사용 목적: 팀의 진행상황을 누구나 투명하게 볼 수 있도록 공유
	- 진행 중에는 팀원 1명당 1개
	- 리뷰에 올린 기능은 팀원이 함께 리뷰
#
## 250114 TIL 
### Pill me 아이디어 구체화
1. 기능 구조도 설계
- 투약기록
	- 처방전/약봉투 인식
		- 카메라 기능 -> OCR 기능
		- 수동 텍스트 대조 -> 투약량/일 확인
		- 투약 정보 삽입
		- 약 정보 - API
	- 사용자 상태 등록
		- 금지된 행위 표시
		- 복용 중 약물 표시 -> 개별 약물 상세내용
- 캘린더
	- 달력
		- 약물 복용 기간
		- 과거 복용 내역
	- 리스트
		- 약물 복용 기간
		- 과거 복용 내역
		- 약물 정보 제공
	- 사용자 전환 기능
		- 전환에 따른 전기능 상태변경
- 커뮤니티
	- 카테고리
		- 즐겨찾기
		- 카테고리 추가
	- 게시글
		- 이미지 삽입
		- 태그 추가
		- 글 작성
		- 스크랩
- 마이페이지
	- 회원가입
		- 이메일 회원가입
		- 구글 회원가입
		- 네이버 회원가입
	- 로그인
		- 이메일 로그인
		- 구글 로그인
		- 네이버 로그인
	- 개인 정보 관리
		- 투약 관리자 관리 -> 팔로우/언팔로우
		- 개인 정보 관리
	- 로그아웃
		-로그아웃
- 알림
	- 본인
		- 복용 시간 설정 -> 투약 알림 관리
	- 관리자
		- 투약 알림 관리
	- 피관리자
		- 투약 알림 관리
2. OCR 기능 정리
3. 로그인 기능 정리
4. 인원 추가 기능 정리
- 로컬
	- 개인 사용자 로컬에서 임의 추가
		- 자유도 높음
		- 타인 승인 불필요
- 글로벌
	- 개인 사용자 팔로잉 팔로우 기능
		- 관리자/피관리자 관계 설정
		- 관리 관계는 유동적으로 설정 가능하고 둘 다 갑을관계 형성 가능
	- 팔로잉 팔로우 기능에 대한 방식 논의
		- 알림 전체 허용 / 비허용 방식
		- 개인별 알림 허용 승인 방식
		- 단방향으로 픽스
#
## 250115 TIL
### GIT 강의
#### GIT이 필수인 이유?
    1. 이력관리 - 모든 변경사항은 기록됨
    2. 분산 버전 관리 - 로컬 저장소와 원격 저장소를 활용한 협업
    3. 협업 효율성 - 여러 사람이 동시에 충돌없이 작업가능
#### 기본 개념
    1. 저장소 - 코드의 과거와 현재를 담은 공간
    2. 커밋 - 변화의 순간을 포착하는 스냅샷
    3. 브랜치 - 아이디어를 실험하고 구현하는 독립적인 공간
    4. 병합 - 아이디어 결과물을 프로젝트에 반영
#### Git 사용 유의점
    1. 커밋 메시지 작성 규칙 - 명확하고 일관적인 메시지 작성이 중요
    2. 브랜치 전략 - 명확한 브랜치 구조는 작업 속도를 높이고 충돌을 최소화
#### 커밋 시 고려해야하는 2가지
    1. 시점 - 논리적으로 완결된 작업 단위
    2. 횟수 - 작은 단위로 자주 커밋
#### 커밋 구성 요소
    - 커밋 ID
    - 작성자 정보
    - 커밋 메시지
#
### 아이디어 피드백
#### 메인 기능 약 정보 기록 자동화 관련
    1. 단순 AI프롬프팅 이용은 규모가 작아보임.
       - 전처리 과정을 확실하게 가져간다면 OK
    2. OCR 이용
       - 알약 데이터를 DB에 넣어 인식된 글자와 비교 또는 검색 쿼리 이용
         - 검색 로직 최적화 필요
         - Elastic Search 추천
       - 병원, 약국 이름 인식의 경우, 정해진 형식이 존재할 것.
         - 사용자의 위치 기반으로 구역을 정해놓고 전국으로 확장하는 방식 권장
    3. 데이터를 모두 처리한 후, 사용자 컨펌 필수
#### TEST 관련
    1. AI프롬프팅, OCR 성능을 100개의 테스트 케이스를 통해 비교해 선택하려는 테스트는 괜찮을지
       - Test 과정은 필수적.
       - 100개는 적고 1000~10000개 정도를 이용
       - 테스트 케이스의 경우, 회전하거나 각도를 조절하여 생성
       - 경량화해서 이용하는 방식도 고려
#### API가 아닌 파일을 통해 데이터베이스에 저장 관련
    1. 스케줄러를 이용해서 DB에 저장
       - 컬럼에 몇 일자에 저장했는지를 넣어 비교하여 관리
    2. 업데이트 중 서비스가 중단시킬 것인지, 지속적으로 이용 가능하게 할지 고려
#### 웹앱 개발에서 PWA 관련
    1. 당위성 측면에서 비추천 -> 카메라 이용에서 불편이 존재할 수 있음.
       - native 또는 hybrid 추천
#### 알림 기능 FCM 및 Kafka 관련
    1. 어떤 형식의 알림을 보내는지를 고려할 것
    2. Kafka는 알림이 정확한 시간(1초 단위)의 오차가 없어야 할 때.
    3. 왜 이 기술들을 사용하는지 학습해볼 것
#### 전반적 피드백
    1. 한 기능에 매몰되지 말고 결과를 정해놓고 쉬운 방법으로 구현 후, 고도화 할 생각을 할 것.
    2. 한 단계씩 맡아 최적화. 단계별로 어떻게 성능을 올릴지 생각해볼 것.
    3. 플로우와 기능에 대한 결과가 중요.
    4. 개인 정보의 경우, 암호화 필요.
#
### 팀원 간 아이디어 기획 이해 일치
- 피드백 진행 후, 2시간 가량 피드백과 기획 전체를 팀원 간 일치시키는 과정을 거침.
- 아이디어를 일치시키는 과정에서 대략적인 플로우를 이용.
- 플로우를 기반으로 UseCase 작성.
#
### Jira 사용
- 코치님께 에픽, 스토리, 테스크 범위 및 예시에 대한 자문.
- 에픽은 1~2주의 큰 단위
- 스토리는 사용자 입장에서의 단위
- 테스크는 개발자 입장에서의 단위
- 팀원들과 진행한 기획을 정리하며 향후 수행할 작업을 일부 작성
#
## 250116 TIL
### 요구사항 명세서
- 팀원들과 프로젝트의 기능에 대한 의견 통합을 위해 요구사항 명세서 작성
- 백엔드 담당의 역할을 분배
- 피부양자 등록은 QR과 초대 링크를 통해 등록 할 수 있어야 한다.
   - 전화번호의 경우, 번호가 변경될 경우의 문제를 우려함.
   - 이메일의 경우, 피보호자(노인)의 이메일을 알기 어려울 것임.

| 기능 | 기능적 요구사항 | 비기능적 요구사항 | 비고 | 도메인 | 담당 |
|-----|--------------|---------------|------|-------|-----|
| 회원가입 | - 회원이 회원가입을 할 때 동일한 아이디가 없는 지 확인해야 한다. | - 회원이 회원 가입을 전송했을 때 5초 이내에 끝나야 한다. <br>- 사용자 정보를 암호화 해야 한다.<br>- 비밀번호는 최소 12자 이상, 대문자/소문자/숫자/특수문자 포함<br>- 회원 탈퇴 시 SOFT DELETE로 한다. | - 이메일 (본인확인용, 이메일 인증) <br>- 비밀번호<br>- 전화번호<br>- 이름 | auth | 정예영 |
| 로그인 | - 사용자가 무조건 로그인을 하도록 한다. | - 로그인 편의성을 위해서 소셜 로그인 기능을 구현한다.<br>- 구현 방법: OAuth, 자체 이메일 로그인 | - OAuth2 사용<br>- 사용자로부터 이메일을 조회할 수 있는 OAuth 인증 수단 개발 | auth | 정예영 |
| 아이디(이메일) / 비밀번호 찾기 | - 자체 인증 서비스에서 사용자가 아이디(이메일) 또는 비밀번호를 분실했을 경우 찾을 수 있도록 한다. | - 비밀번호 찾기 때 이메일 전송은 비동기 처리로 해야 한다. | | auth | 정예영 |
| 복용 약물 등록 | - 사용자의 복용 약물 정보 관련 사진을 통해서 약물 정보를 등록하도록 한다. <br>- 사용자가 직접 등록할 수 있도록 한다.<br>- 사용자가 방문한 병원을 등록할 수 있도록 한다.<br>- 부양자를 추가했을 경우 부양자의 복용 약물을 등록할 수 있도록 한다. |- 사진을 통해서 등록 하는 경우 OCR과 AI 기능을 활용하여 개발하여야 한다.<br>- 등록한 사진으로부터 가져온 텍스트의 부정확함을 보완하기 위해 사용자 확인 및 수정 필요 | - 복용 약물 리스트 PK를 다른 곳에 FK로 사용할 때 암호화 하는 정책을 나중에 논의 해봐야 한다. <br>- 엘라스틱 서치(연관 검색어로 수동 등록이 용이하게 함) | medicine | 오세학
| 복용 약물 알림 | - 사용자가 설정한 시간에 맞춰서 복약 알림을 보낸다. <br>- 부양자는 피부양자의 약물 복약 알림을 설정할 수 있어야 한다.<br>- 알림 설정은 1시간 단위로 설정해야 한다. | - 플랫폼 제약 없이 사용해야 하기 때문에 FCM과 Kafka를 활용하여 개발해야 한다.<br>- 알림은 설정된 시간 +- 1분에 사용자에게 도착해야 한다. | | notification | 임태훈
| 복용 약물 관리 | - 사용자는 자신이 복용한 약물을 체크 및 체크 해제할 수 있어야 한다.<br>- 피부양자의 복용 약물을 관리할 수 있어야 한다.<br>- 피부양자는 부양자가 추가한 약물을 삭제할 수 없다.<br>- 피부양자가 금일 복용한 약물 기록을 부양자는 조회할 수 있다. | - 데이터베이스에 복용 약물 사실 컬럼을 특정 시간에 복용 약물 기록 테이블에 삽입하고 초기화 해야 한다.<br>- 피부양자의 약물 복용 사실을 부양자는 실시간으로 확인해야 한다. | - 폴링 방식으로 구현해야 할 지, 아니면 직접 새로고침으로 진행해야 할 지 선택해야 한다.(컨설팅 받기)<br>- FE 개발자에게 폴링 방식과 오프라인 방식을 분리하도록 하자. | medicine, log | 오세학
| 부양자 등록 | - 사용자는 자신이 부양해야 하는 개체의 약물 복용을 관리할 수 있어야 한다. | - 등록의 용이성을 위해서 초대 코드 및 QR 코드로 피 부양자를 등록해야 한다. | auth 도메인이 개발된 다음에 착수 | management | 
| 채팅 | - 관리자 & 피부양자 간 채팅 | - 텍스트 및 이미지 전송이 가능해야 한다. | | chat | 조승근
| 마이페이지 | - 사용자 정보 수정<br>- 피부양자 등록은 QR과 초대 링크를 통해 등록 할 수 있어야 한다. | | - auth와 user 도메인이 개발된 다음에 착수해야 함 | user
| 커뮤니티 | - 건강 향상 증진을 위한 챌린지 형식의 커뮤니티 기능을 해야 한다. | | | community
| 전체 회원 관리 | - 관리자는 전체 회원의 부양, 피부양 여부를 관리할 수 있어야 한다. | | | admin
#
### 백엔드 코드 컨벤션
    - 패키지 구조 컨벤션 정의
    - Commit 컨벤션 정의
    - Branch 전략 정의
    - 템플릿 (기능, 버그, PR 신청) 정의
    - DTO 구조 정의
    - 응답 규칙 정의
#
## 250117 TIL
### Jira 사용
    1. 팀원들과 에픽/스토리/테스크를 세분화하는 방법 토의 및 설계
    2. 설계된 방안으로 Jira 수정
    3. 각 이슈에 대한 스토리 포인트 설정 및 스프린트 생성
#
### ERD 설계
    1. ERD Cloud를 이용하여 ERD 설계 진행
    2. 약물, 날짜별 복용 관리, 복용 기간 관리 테이블을 설계 시, 스케줄러를 사용하는 경우와 사용하지 않는 경우에 대해 데이터 관리 및 성능 토의
    3. 사용하지 않는 방식으로 설계
#
## 250120 TIL
### Git
    Rebase란?
       - 브랜치의 기반(base)을 다른 커밋으로 변경하는 것
       - conflict가 처음 발생한 이후의 커밋마다 충돌을 해결해야 함
       - 히스토리를 건드는 명령어이므로 이미 push된 내용을 reabse 할 경우, 팀원 코드와 꼬일 수 있음
       - 따라서, 로컬 브랜치에서만 rebase 사용
       - rebase된 내용을 원격 repo에 push할 땐, 옵션 사용에 주의
         - --force(x), --force-with-lease(o)
       - rebase가 원격 repo에 반영되었다면, 팀원들은 원격 repo의 내용을 로컬에 반영 후 작업 수행
         - git fetch origin, git reset --hard origin/브랜치명
#   
### 백엔드 기술 공유
    1. 로그인/회원가입
       - 회원가입 시 전화번호를 저장해야하는데 네이버, 카카오는 OAuth를 사용하게 되면 정보를 받아올 수 있으나 구글은 불러올 수 없음.
       - 전화번호 인증 작업 -> 메시지로 인증
       - 오프라인 시 알림을 받을 수 없으므로 로그인을 길게 유지시킨다면 보안에 취약할 우려가 있음.
    2. FCM
       - PWA는 앱 환경이 아닌 웹 환경과 같기 때문에 FCM 로직 자체는 유사함.
       - 오프라인/자동 로그아웃된 환경에서 알림이 가능한지? -> 디바이스에 저장한다면 가능.
       하지만 이 경우, 다른 플랫폼에서 알림 설정을 변경 할 경우 반영하기가 어려움.
       - 여러 기기에서 한 계정을 사용하는 경우/한 기기에서 여러 아이디를 사용하는 경우를 고려하면 기존의 USER테이블에 저장하는 방식이 아닌 FCM 토큰을 관리하는 테이블을 분리하여 관리해야함.
    3. 약 정보 저장
       - 엘라스틱 서치를 통해 연관 검색어/오타 정정 기능/인기 검색어 기능 구현 가능
    4. 채팅
       - AWS 서버가 1개 주어지기 때문에 Kafka 전용 서버를 둘 수 없기 때문에 의미가 퇴색될 수 있음.
#
### PWA
    - PWA는 2개의 다른 운영 체제를 이어주는 역할.
    - service worker가 html, css, js를 저장 및 관리.
      - 따라서 저장 및 관리되는 코드에는 민감한 정보가 존재하면 안됨.
    - service worker는 device에 존재하는 것이고 필요할 때마다 활성화되는 것.
    - TCP/UDP를 직접 생성하고 제어하는게 불가능한 이유는 브라우저 샌드박스 보안 정책 때문.
      - 샌드박스 -> 보안을 위해 제한된 격리 실행 환경을 따로 줘서 기능들이 제한됨.
#
## 250121 TIL
### 데이터베이스 인덱스
#### 기본 원리
- 테이블의 특정 컬럼에 대해 정렬된 형태로 별도 저장됩니다
- 컬럼의 값과 해당 레코드의 위치 정보를 가지고 있습니다
- B+Tree 구조가 가장 일반적으로 사용됩니다

#### 장점
- 검색 속도가 매우 빨라집니다
- ORDER BY 등의 정렬 연산을 빠르게 처리할 수 있습니다
- 특정 컬럼의 유일성을 보장할 수 있습니다 (Unique Index)

#### 단점
- 추가적인 저장 공간이 필요합니다
- INSERT, UPDATE, DELETE 시 인덱스도 함께 수정해야 하므로 성능 저하가 발생합니다
- 잘못 설계된 인덱스는 오히려 성능을 저하시킬 수 있습니다

#### 인덱스 종류
- 단일 인덱스: 하나의 컬럼으로 구성
- 복합 인덱스: 여러 컬럼을 조합하여 구성
- 클러스터드 인덱스: 데이터가 물리적으로 정렬되어 저장
- 비클러스터드 인덱스: 데이터와 별도로 인덱스만 정렬

#### 인덱스 사용이 효과적인 경우
- WHERE 절에서 자주 사용되는 컬럼
- JOIN에 자주 사용되는 컬럼
- 데이터의 선택도(Selectivity)가 높은 컬럼
- ORDER BY나 GROUP BY에 자주 사용되는 컬럼

### 인덱스가 존재할 때와 존재하지 않을 때의 성능 차이

#### 테이블 전체 검색 (Full Table Scan)

- 인덱스 없음: O(N) - 모든 레코드를 순차적으로 검색
- 1백만 건 데이터 기준: 약 2-3초 소요

#### 인덱스를 활용한 검색 (Index Scan)
- 인덱스 있음: O(log N) - B+Tree 구조 활용
- 1백만 건 데이터 기준: 약 0.1초 미만 소요

#### 인덱스가 오히려 성능을 저하시키는 경우
- 대량의 데이터를 조회하는 경우
- 데이터 입력/수정이 빈번한 경우

일반적으로 10-15% 미만의 데이터를 조회하는 경우 인덱스가 효과적이며, 그 이상의 데이터를 조회할 때는 전체 테이블 검색이 더 효율적일 수 있음.

### 팀 전체 회의
    * 프론트에서 완성한 피그마와 백엔드에서 작성한 요구사항 명세서를 통해 의견 통합 진행
    * 기능 구현 부분은 기능 완성 후 단계적으로 확장하는 방식으로 채택
    * 피그마를 확인하며 기능을 함께 고려했을 때, 팀원 간 기능에 대한 의견 통일

### Jira 번다운 차트에 영향을 주는 것
    - 스프린트 작업량 변경
        이슈의 스토리 포인트 수정
        이슈의 예상 시간 수정

    - 스프린트 범위 변경
        스프린트에 이슈 추가
        스프린트에서 이슈 제거

    - 이슈 상태 변경
        To Do → In Progress
        In Progress → Done
        Done → In Progress 등
#
## 250122 TIL
### 면접단골 질문
- SOLID
  1. Single Responsibility Principle (단일 책임 원칙)
    - 한 클래스는 하나의 책임만 가져야 한다.
  2. Open-Closed Principle (개방-폐쇄 원칙)
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    - 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 한다.
  3. Liskov Substitution Principle (리스코프 치환 원칙)
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램의 정확성을 깨뜨리지 않아야 한다.
    - 상속은 올바른 계층 구조에서만 사용되어야 한다.
  4. Interface Segregation Principle (인터페이스 분리 원칙)
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
    - 하나의 큰 인터페이스보다 여러 개의 작은 인터페이스가 좋다.
  5. Dependency Inversion Principle (의존성 역전 원칙)
    - 추상화는 세부 사항에 의존하지 않아야 한다. 세부 사항이 추상화에 의존해야 한다.
- D(Do not)R(Repeat)Y(Yourself) : 중복을 피해라, 코드 중복 피하기/자동화
- K(Keep)I(It)S(Simple)S(Stupid) : 너무 정교한 것에 집착하지마라. 간단하고 멍청해보이는 것으로 접근
- Y(You)A(Ain't)G(Gonna)N(Need)I(It) : 오버 엔지니어링 하지마라

### ERD 재작성
    * 기존의 약물 복용 관리 테이블 구조는 미래의 불필요한 비어있는 row들이 생성될 수 있음.
      따라서, 복약 관리 테이블에 약을 먹었는지 체크한 내역을 히스토리 테이블로 스케쥴러를 통해 저장하기로 변경
    * 알림을 수신했는지 여부를 확인하기 위해 fcm 응답 대한 테이블 생성
    * 의존관계를 요청했을 때 동의 여부와 부양자의 약물 추가/삭제를 동의하는지에 대한 알림을 위해 테이블 생성

### Jira 구조 변경
  - 기존의 1주 단위 에픽 설정, 사용자의 관점에서의 스토리, 개발자 관점에서의 하위 테스크는 스토리 포인트를 반영하지 못하기 때문에 구조 변경
  - 기능 별로 에픽을 선정하고 스토리는 팀원 각자의 업무로 변경

### FCM
#### FCM이란?

- 무료로 메시지를 전송할 수 있는 교차 플랫폼 메시징 솔루션
- Google의 클라우드 메세징 서비스로, 쉽게 실시간 푸시메세지를 구현할 수 있음.
- FCM 토큰이라는 것으로 사용자를 식별할 수 있으며, 이 토큰만 가지고 있으면 손쉽게 푸시메세지를 발행 할 수 있음.
- FCM 서버는 Google이 관리하고 있으므로, 구현이 복잡하지 않음.

#### 왜 사용하는가?

- FCM을 이용하면 플랫폼에 종속되지 않고 푸쉬 메시지를 전송할 수 있음.
- iOS, Android, Web 각 플랫폼에서 푸쉬 메시지를 보내려면 각 플랫폼 환경별로 개발해야하는 불편함이 있는데 이를 하나로 통합하는 솔루션임.

#### 클라우드 메시징 서비스를 사용하면 어떤 이점이 있는가?

- 서버를 경유해서 실시간으로 푸쉬 메시지를 받으려면 사용자는 항상 서버에 접속해있어야하는데 이는 사용자 기기의 배터리 및 네트워크 리소스를 크게 낭비한다.
- 클라우드 메시징 서버를 중간에 둠으로써, 사용자는 낮은 배터리와 네트워크의 사용만으로도 메세지를 실시간으로 송수신 처리를 할 수 있다.
- 위와 같은 이유로 대부분의 어플리케이션 서비스들은 클라우드 메시징 서버를 경유해서, 실시간으로 유저들에게 메시지를 전송해주고 있다.

#### 주요 기능

1. **메시지 전송 기능**
    - 알림 메시지: 사용자에게 직접 보이는 일반적인 푸시 알림
    - 데이터 메시지: 앱이 직접 처리하는 데이터 형태의 메시지
2. **메시지 타겟팅**
    - 개별 기기로 전송
    - 특정 기기 그룹으로 전송
    - 특정 주제를 구독한 모든 기기로 전송
3. **양방향 통신**
    - 서버에서 클라이언트로의 통신
    - 클라이언트에서 서버로의 통신이 모두 가능

#### 시스템 구성

1. **서버 환경**
    - FCM 연결 서버
    - 애플리케이션 서버 (HTTP/XMPP 기반)
    - 클라우드 기능
2. **클라이언트 환경**
    - iOS, Android, 웹 애플리케이션

#### 작동 방식

1. **기기 등록 단계**
    - 앱 설치 시 FCM 서버에 등록
    - 고유한 FCM 토큰 발급 받음
2. **메시지 전송 과정**
    - 서버에서 메시지 생성
    - FCM 백엔드에서 메시지 처리
    - 플랫폼별 전송 시스템을 통해 메시지 전달
    - 사용자 기기에서 메시지 수신
3. **분석 기능**
    - Google 애널리틱스와 통합되어 있어 메시지 효과 측정 가능
    - 사용자 반응 및 참여도 추적 가능
#
## 250123 TIL
### UI 회의
  1. 메인 페이지
      - nav bar에 존재하던 버튼을 페이지 내부로 이동
      - 복용 내역 리스트를 위로 이동시키고 캘린더 컴포넌트를 재사용하기 위해 메인에도 위치
  2. 캘린더 페이지
      - 캘린더 하단에 전체/아침/점심/저녁/잠자기 전 버튼을 두고 그 날에 먹는 각각의 약 리스트 출력
      - 기존의 아침/점심/저녁/잠자기 전 체크 박스를 단일 체크 박스로 변경
      - 아침/점심/저녁/잠자기 전 단위로 일괄 복용 체크 버튼 생성
  3. 알림 페이지
      - 읽음 처리/삭제 버튼을 삭제 버튼으로 변경
      - 일괄 읽음 처리/삭제 버튼 생성
### 알림 API 명세서 작성 및 토의
  - 약 봉투 및 처방전을 통해 약 리스트를 받아오면서 각 약들을 언제 먹는지 사용자에게 받기로 결정
  - 아침/점심/저녁/잠자기 전 단위로 복용 체크가 되면 알림을 보내지 않기로 결정
  - 알림 시간 설정 생성
  - 알림 시간 설정 수정
  - 알림 끄기(삭제)
  - 알림 시간 설정 가져오기
  - 알림 보내기
  - 알림 리스트
  - 알림 읽음
  - 알림 삭제
#
## 250124 TIL
### 프로젝트 팀원들과 협업하는 자세
- I-statement
    - 상대방이 중심이 되면 비난처럼 들림
    - 내가 느끼는 바에 좀 더 포커스를 두고 말하기

- 공통의 목표 환기하기

- 상대의 입장 확인하기
    - 상대가 왜 그런 선택했는지 한 번 쯤 이해해보고 이걸 언급하면 상대도 받아들이기도 쉬움
### FCM 테스트
    - 알림이 허용된 웹의 FCM 토큰을 가져올 수 있는 프론트 화면(Vue.js) 구성
    - 프론트에서 받아온 FCM 토큰을 이용하여 알림 메시지를 전송하는 api 구현
#
## 250126 TIL
### FCM 테스트 환경 실행
    1. 프론트에서 FCM 토큰을 가져오고 받은 메시지를 보여주는 화면 구성
       * 이 과정에서 PWA관련 설정이 없었는데 계속해서 이전에 실행시킨 PillMe 화면 관련되어 PWA 에러가 발생
        -> 캐시 삭제 후, 실행하여 정상적으로 동작
       * FCM 토큰을 이용하여 백엔드에서 알림이 정상적으로 보내지고 화면에서 알림 메시지가 정상적으로 오는 것을 확인. 하지만 기기(노트북)에서 알림 팝업이 뜨지 않음.
        -> 시스템 >> 알림 및 작업 >> 알림 받기 활성화 를 통해 해결(기존에 알림을 비활성화 했었음.)
#
## 250127 TIL
### 사용자 알림 설정 기능 구현
- 사용자에게 약 복용 시간(아침/점심/저녁/잠자기 전)을 받아 관리하는 기능 구현(CRUD)
- 현재는 API명세서에 따라 CRUD 모두 구현했는데 이 방식은 프론트에서 로직이 늘어나게 된다.
  - 사용자 알림 설정의 존재 여부에 따라 create, update로 나누어야 한다.
  - hard delete이기 때문에 계속해서 create, update 방식으로 구현해야 한다.
- 대안 방안(협의 필요)
  - create와 update 로직을 합쳐 사용자 알림 설정이 존재하지 않으면 create, 존재하면 update하는 방식
  - delete시 알림 시간을 null로 update -> soft delte
  - null 값이 저장되기 때문에 데이터 관리 필요
#
## 250128 TIL
### FCM 토큰 저장
- 고려한 점
  - 사용자가 여러 기기에서 로그인할 수 있음
  - 이에 따라, FCM 토큰 테이블을 회원과 분리해서 따로 저장
  - 모든 기기에 알림을 보내는 방안과 최근에 획득한 FCM 토큰에 해당하는 기기에만 알림을 보내는 방안 존재
  - 우선, 모든 기기에 알림을 보내는 방안으로 채택
### 사용자가 설정한 시간에 알림을 보내는 방식 (스케줄러 및 Quartz)
#### 스케줄러 방식
    * 장점
      1. 구현이 단순하고 빠른 개발 가능
      2. Spring Boot기본 기능으로 추가 의존성 불필요
      3. 소규모 시스템에 적합
      4. 간단한 주기적 잡업에 효율적
    * 단점
      1. 동적 스케줄 변경 불가 (서버 재시작 필요)
      2. 클러스터링 환경에서 중복 실행 가능성
      3. 실행 이력 관리 어려움
      4. 오류 발생 시 재시도 메커니즘 부재
    * 적합한 경우
      1. 프로토타입 또는 MVP 개발
      2. 단일 서버 환경
      3. 사용자 수가 적은 경우
      4. 고정된 스케줄로 충분한 경우
#### Quartz 라이브러리
    * 장점
      1. 동적 스케줄 관리 가능
      2. 클러스터링 지원
      3. 실행 이력 관리 용이
      4. 장애 복구 및 재시도 메커니즘
      5. DB를 통한 스케줄 영속성 지원
    * 단점
      1. 구현이 상대적으로 복잡
      2. 추가 의존성 필요
      3. 초기 설정에 시간 소요
      4. 학습 곡선이 존재
    * 적합한 경우
      1. 대규모 사용자 환경
      2. 클러스터 환경
      3. 동적 스케줄 변경 필요
      4. 실행 이력 관리가 중요한 경우           
#
## 250129 TIL
### 팀 회의
- 지난 스프린트 내용 회고 및 스프린트 완료
  - 각자 학습한 내용에 따라 필수 기능들에 우선순위를 변경
  - 수행한 업무 브리핑
- 백로그 생성 및 새로운 스프린트 시작
  - 회고를 기반하여 우선적으로 개발해야할 필수 기능을 백로그에 생성
- AI 시연
  - 스캔하는 방법 학습(OpenCV 등) -> 어느정도 성능이 나오는지 결과물 알아보기
  - OCR 단어 추출 방법 학습
  - 개체명 인식 AI -> 모델 찾기 및 학습시키기
  - 각각에서 추출된 데이터 결과값으로 시연
  - 각각 데이터를 뽑아오고 학습시킨 모델로 어떤 데이터를 던졌을 때, 어느 정도의 정확도가 나오고 어떤 결과가 나오는지를 시연
### 사용자가 설정한 시간에 알림을 보내는 기능
  - 우선, 단순 스케줄러를 이용하여 구현하고 확장
  - 스케줄러 구현
    - main application에 @EnableScheduling 필요
    - 현재는 매 분 0초에 알림 설정 테이블에서 현재 시간(시와 분)에 해당하는 알림을 가져온 후, 사용자의 등록된 FCM 토큰들을 확인하여 알림을 전송하는 방식
#
## 250130 TIL
### 스케줄러를 이용한 복용 알림 기능 테스트
    1. 더미 회원 데이터를 저장
    2. 프론트에서 FCM 토큰을 받아와 저장
    3. 사용자 입력으로 받은 알림 시간 저장
    4. 매 분 스케줄러를 통해 저장된 알림 시간과 현재 시간을 비교한 후, 해당 회원의 FCM 토큰 확인
    5. 복용 알림 전송
### 알림 권한 상태
#### 브라우저 알림 권한
- Notification API를 이용하여 알림 권한 상태 확인 및 권한 요청 가능
   ``` javascript
   // 현재 알림 권한 상태 확인
  const checkNotificationPermission = async () => {
    if (!('Notification' in window)) {
      return 'notifications-not-supported';
    }
  
    return Notification.permission; // 'default', 'granted', 'denied' 중 하나를 반환
  };
  // 알림 권한 요청
  const requestNotificationPermission = async () => {
    try {
      const permission = await Notification.requestPermission();
      return permission;
    } catch (error) {
      console.error('알림 권한 요청 중 에러 발생:', error);
      return 'error';
    }
  };
   ```
#### 디바이스(노트북, 스마트폰 등) 알림 권한
- PWA는 브라우저 레벨의 권한에만 접근이 가능.
- 따라서, 시스템 설정은 사용자가 수동으로 변경해야 함.
- 디바이스 알림 설정하는 방법을 설명해주기.
``` javascript
// 윈도우 알림 설정 예시
function showWindowsNotificationGuide() {
  alert(`Windows 알림 설정 확인 방법:
1. 설정 > 시스템 > 알림 및 작업으로 이동
2. '앱 및 다른 보낸 사람의 알림 받기' 옵션 확인
3. 브라우저 앱(Chrome, Edge 등)의 알림 허용 여부 확인`);
}
// 안드로이드 알림 설정 예시시
function showAndroidNotificationGuide() {
  alert(`Android 알림 설정 확인 방법:
1. 설정 > 알림으로 이동
2. 앱 설정에서 브라우저 앱 찾기
3. 알림 허용 여부 확인 및 설정`);
}
```
### 처방전 및 약 봉투 자동화 기능 생각하는 방향
#### 1. 이미지 획득 및 전처리 단계 
- 이미지 품질 향상(OpenCV, scikit-image, PIL)
#### 2. 문서 구조 분석 
- 관심 영역(ROI) 검출
- 텍스트 영역 세그멘테이션 
- Layout Parser: 문서 구조 분석
- PaddleOCR: 텍스트 영역 검출
- Detectron2: 객체 검출
#### 3.OCR 처리
- 텍스트 추출 및 인식
- Tesseract-OCR with Korean training data
- EasyOCR: 다국어 지원
- PaddleOCR: 높은 정확도
#### 4. 정보 추출 및 구조화
- 의약품 정보 식별
- BERT 기반 개체명 인식(NER)
- BiLSTM-CRF
- 규칙 기반 패턴 매칭

#### 5. 데이터 검증 및 보정
- 의약품 DB 매칭
- 오타 교정
- Fuzzy String Matching
- Levenshtein Distance

#### 6. 데이터베이스 저장 및 관리
- PostgreSQL: 관계형 데이터베이스
- ElasticSearch: 검색 엔진
- Redis: 캐시 및 임시 저장소

### 시나리오
1. 사용자 이미지 업로드
2. 이미지 전처리
3. 관심 영역 검출(ROI)
4. OCR 처리 -> "이 이미지에 어떤 글자가 있는지"
5. 텍스트 전처리 & 유사도 매칭 -> "OCR 오류 보정"
6. 정보 추출(개체명 인식 AI(NER)) -> "이 글자가 약품명인지 판단"
7. 정보 검증
8. 결과 반환

#### OCR 모델 비교
1. PaddleOCR
- 장점
    - 한글 인식 성능이 우수
    - 텍스트 검출과 인식이 통합
    - GPU 가속 지원으로 빠른 처리
    - 지속적인 업데이트
- 단점
    - 설치가 다소 복잡
    - GPU 없이는 처리 속도가 느림
2. Tesseract
- 장점
    - 설치와 사용이 간단
    - 다양한 언어 지원
    - 오픈소스로 무료 사용
- 단점
    - 한글 인식 정확도가 상대적으로 낮음
    - 처리 속도가 느림
    - 복잡한 레이아웃 처리가 어려움
3. EasyOCR
- 장점
    - 사용이 매우 간단
    - 한글 지원이 잘됨
    - Deep Learning 기반으로 정확도가 높음
- 단점
    - 처리 속도가 상대적으로 느림
    - 메모리 사용량이 많음
#### NER 모델 비교
1. KLUE-BERT
- 장점:
    - 한국어에 최적화된 성능
    - 다양한 태스크에 활용 가능
    - 풍부한 사전학습 데이터
- 단점:
    - 모델 크기가 큼
    - 학습에 많은 리소스 필요
    - 도메인 특화 데이터로 추가 학습 필요
2. KoBERT
- 장점:
    - 한국어 특화 모델
    - 상대적으로 가벼운 모델 크기
    - 커뮤니티 지원이 활발
- 단점:
    - KLUE-BERT 대비 성능이 다소 낮을 수 있음
    - 최신 업데이트가 적음
3. BiLSTM-CRF
- 장점:
    - 모델 크기가 작음
    - 학습이 상대적으로 빠름
    - 메모리 사용량이 적음
- 단점:
    - Transformer 기반 모델 대비 성능이 낮을 수 있음
    - 긴 문장 처리에 취약할 수 있음
### 텍스트 전처리 & 유사도 매칭 예시
#### Funzzy Matching(유사도 매칭)
``` python
from fuzzywuzzy import fuzz

def correct_drug_name(ocr_text, drug_database):
    best_match = None
    highest_ratio = 0

# 약품 데이터베이스와 비교
    for drug in drug_database:
# 유사도 계산 (0-100 점수)
        similarity = fuzz.ratio(ocr_text, drug)
        if similarity > highest_ratio and similarity > 80:# 80% 이상 유사
            highest_ratio = similarity
            best_match = drug

    return best_match, highest_ratio
```
#### 자주 발생하는 OCR 오류 보정
``` python
def preprocess_ocr_text(text):
# 일반적인 OCR 오류 수정
    corrections = {
        'o': '0',# 숫자 0을 알파벳 o로 잘못 인식
        'l': '1',# 숫자 1을 알파벳 l로 잘못 인식
        'rng': 'mg'# mg를 rng로 잘못 인식
    }

    for wrong, correct in corrections.items():
        text = text.replace(wrong, correct)

    return text
```
#### 정규표현식을 통한 패턴 인식
``` python
def validate_format(text):
# 약품명 패턴 (예: OO정, OO캡슐)
    drug_pattern = r'[가-힣a-zA-Z]+[정|캡슐|시럽|주사]'

# 용량 패턴 (예: 500mg, 5ml)
    dosage_pattern = r'\d+(?:mg|ml|g)'

    if re.match(drug_pattern, text):
        return 'DRUG_NAME'
    elif re.match(dosage_pattern, text):
        return 'DOSAGE'
```
#
## 250131 TIL
### 역할 재분배
- 이미지 처리 및 관심 영역 추출, OCR - 프론트 1명
- 개체명 인식 - 백엔드 1명
- 남은 인원은 메인 핵심 기능을 우선적으로 개발
### 백엔드 코드 1차 리뷰 - 알림
- 기존 컨벤션대로 ResponseEntity로 JSONResponse를 래핑할 것
- FCMConfig는 global 패키지에 적합
- 백엔드 기능 전체 통합으로 기존 테스트 코드에서 사용한 UserRepository를 MemberRepository로 변경
### SSE(Server-Sent Events)
- 작동 방식 : HTTP를 통한 단방향 서버 푸시 기술
- 연결 특성 : 지속적인 연결 유지 필요
- 프로토콜 : 일반 HTTP/HTTPS 사용
- 동작 과정
  1. Client -> Server로 SSE 연결 요청
  2. Server에서 클라이언트와 매핑되는 SSE 통신 객체 만들기
  3. Server -> Client로 서버 데이터 변경 시 해당 SSE 객체를 통해 데이터 전달달
- 구현은 비교적 단순하고 실시간으로 데이터를 보낼 수 있음. 
- 하지만, 각 클라이언트와의 연결을 유지해야 하므로 서버 리소스 소비가 큼. 클라이언트가 오프라인일 때 메시지 수신 불가.
### FCM(Firebase Cloud Messaging)
- 작동 방식 : Google의 클라우드 메시징 서비스
- 연결 특성 : 필요할 때만 메시지 전송 (연결 유지 불필요)
- 프로토콜 : XMPP 또는 HTTP/HTTPS
- 서버 자원 : Google 인프라를 활용하므로 서버 부하 적음
- 동작 과정
  - 클라이언트가 FCM 서버에 등록되는 과정
    1. Client -> FCM으로 FCM 서버에서 유저별로 고유하게 발급되는 FCM 토큰 요청
    2. FCM -> Client로 요청한 토큰(키) 전달
    3. Client -> Server에 FCM 토큰 전달
    4. Server에서 FCM 토큰을 DB에 저장
  - 서버가 데이터를 전달하는 과정
    1. DB에서 특정 사용자의 토큰 추출
    2. Sever -> FCM으로 특정 토큰, 데이터를 HTTP를 이용하여 FCM에 전달
    3. FCM -> Client로 전달받은 토큰을 식별해서 클라이언트에 데이터 전달
- Firebase 설정이 필요하고 SSE에 비해 느릴 수 있음. FCM 서버에 의존하기 때문에 FCM 서버 상태에 따라 지연될 가능성 존재.
- 하지만, 교차 플랫폼 메시징 서비스이므로 다양한 플랫폼을 지원하고 오프라인 메시지를 지원.  
#
## 250201 TIL
### FCM에서 Data와 Notification 페이로드
    * Data 페이로드
      - 개발자가 정의한 커스텀 데이터를 key-value 형태로 전달
      - 앱이 포그라운드/백그라운드 상태와 관계없이 항상 onMessageReceived()로 전달
      - 앱에서 직접 알림 생성 및 처리 방식을 구현할 수 있음
      -  최대 4KB까지 전송 가능
    * notification 페이로드
      - 미리 정의된 키-값 쌍을 사용하여 푸시 알람의 표시 방식을 지정.
      - 포그라운드에서 onMessageReceived()로 전달. 백그라운드에서 Notification의 title과 body 항목대로 푸쉬를 자동으로 만들며 터치시 기본적으로 앱을 구동시킴. 
      - 제한된 필드만 사용 가능(title, body, icon 등)
    * notification + data
      - 포그라운드
        - 알림이 자동으로 표시되지 않음
        - onMessageReceived()에서 data와 notification 모두 수신 가능
        - 개발자가 직접 알림 생성 및 처리 가능
      - 백그라운드
        - notification 내용으로 시스템 알림이 자동 생성됨
        - data 페이로드는 알림 클릭 시 인텐트로 전달됨
        - pendingIntent를 통해 data 정보 접근 가능
#
## 250202 TIL
### JPA In절 사용
- JPA에서 IN절은 여러 값들에 대해 매칭되는 데이터를 조회 가능
  ```java
  List<User> findUserInAges(List<Integer> ages);
  ```
- IN절에 너무 많은 파라미터를 전달하면 성능이 저하될 가능성 존재
- 데이터베이스마다 IN절 파라미터 제한이 다를 수 있음
### 벌크 업데이트
- 벌크 업데이트는 여러 엔티티를 한 번의 쿼리로 수정하는 작업
- 영속성 컨텍스트를 무시하고 직접 데이터베이스에 쿼리를 실행
- 단일 쿼리로 처리되어 성능상 이점이 존재
```java
@Modifying
@Query("UPDATE User u SET u.status = :status WHERE u.lastLoginDate < :date")
int updateUserStatus(@Param("status") String status, @Param("date") LocalDateTime date);
```
- 주의사항
  - 영속성 컨텍스트와의 동기화 문제 -> 벌크 연산 이후, 영속성 컨텍스트 초기화 필요
    ```java
    @Modifying(clearAutomatically = true)
    @Query("UPDATE User u SET u.status = :status WHERE u.id IN :ids")
    int updateUserStatus(@Param("status") String status, @Param("ids") List<Long> ids);
    ```
  - 트랜잭션 관리
    ``` java
    @Transactional
    public void updateUsers() {
    // 벌크 연산 수행
    int updatedCount = userRepository.updateUserStatus("INACTIVE", ids);
    
    // 필요한 경우 영속성 컨텍스트 초기화
    entityManager.clear();
    
    // 이후 로직 수행
    }
    ```
- 벌크 연산 사용 시 고려사항
  1. 영속성 컨텍스트와의 정합성
    - 벌크 연산 전에 영속성 컨텍스트 플러시
    - 벌크 연산 후에 영속성 컨텍스트 초기화
  2. 성능 최적화
    - 대량의 데이터 처리 시 배치 크기 설정
    - 인덱스 활용 고려
    3. 데이터 정합성
    - 낙관적 락이나 비관적 락 고려
    - 동시성 이슈 검토
#
## 250203 TIL
### 코드 리뷰
#### 리뷰를 기다릴 때 idle 시간이 존재한다면?
- 태스크를 병행하면서 리듬찾기
- 한 태스크가 리뷰를 기다리는 중이라면 다른 태스크 구현을 시작한다
#### 리뷰어는 빠르게 응답
- 엉성한 리뷰를 하라는 얘기가 아니라, 초기 응답이라도 빠르게 해야함
#### 코드 짧게 유지하기
- 500~800 라인 정도가 적당
#### 추상화 잘하기
- 복잡성을 단순함에 숨기기
#### 여러 설명 수단 활용하기
- 필요하면 대면, UML, 스크린샷 등 리뷰어가 이해하기 쉽게.
### 초기 MVP 구현 방안에 대한 시나리오
#### 1번 방안 ChatGPT 프롬프트
      1. 사용자 이미지 업로드
      2. 이미지 전처리 - OpenCV 이용
      3. AI 프롬프트를 이용하여 약품 정보 추출 - ChatGPT 이용
      4. 정보 검증 - 회원에게 검증
      5. 결과 저장
#### 2번 방안 세부적인 과정 처리
      1. 사용자 이미지 업로드
      2. 이미지 전처리 - OpenCV 이용
      3. 관심 영역 검출
      4. OCR 처리 - paddle 이용
      5. 텍스트 전처리 & 유사도 매칭 - OCR 오류 보정을 위함
      6. 정보 검증 - 회원에게 검증
      7. 결과 저장
### 한 개의 회원 아이디에 여러 개의 사용자 등록 방안 고찰
- 기존 ERD를 유지하며 여러 사용자를 한 회원의 아이디에 등록할 수 있는 방안을 고민
- 이름, 성별, 생년월일, 역할(LOCAL) 외의 데이터는 더미 값을 저장시켜 새로운 회원 데이터를 만든 뒤, dependency 테이블에 보호자(아이디를 가지는 회원), 피보호자(새로운 회원)을 등록하여 이용
- 이로 인해 만들어진 회원은 복약 내역만 관리 가능
#
## 250204 TIL
### 처방전/약봉투 정보 추출 자동화 시스템 분석

#### 1. ChatGPT 프롬프트 활용 방안

#### 프로세스 상세 설명

1. **사용자 이미지 업로드**
   - 웹/모바일 인터페이스를 통한 이미지 업로드
   - 이미지 포맷 검증 및 초기 품질 체크

2. **AI 프롬프트를 이용한 정보 추출 (ChatGPT)**
   - GPT 모델을 통한 의약품 정보 구조화
   - 추출된 정보의 포맷팅 및 정규화

3. **정보 검증 (회원)**
   - 추출된 정보의 사용자 확인 인터페이스 제공
   - 오류 수정 기능 제공
   - 피드백 데이터 수집

4. **결과 저장**
   - 검증된 데이터의 데이터베이스 저장
   - 이력 관리 및 백업

### 문제점 및 한계

1. **정확도 관련 이슈**
   - 이미지 품질에 따른 인식률 변동
   - 특수 의학 용어 처리의 불확실성
   - GPT 내부에 Tesseract OCR 이용으로 한국어 데이터 파일이 누락되어 있어 텍스트를 추출 불가
   - GPT 모델의 한글 의약품명 인식 한계

2. **보안 및 개인정보**
   - 외부 AI 서비스 사용에 따른 정보 유출 위험
   - 의료정보 보안 규정 준수 필요
   - 데이터 암호화 및 보안 처리 부담

3. **비용 구조**
   - API 호출 비용 발생
   - 처리량 증가에 따른 비용 상승
   - 장기적 운영 비용 부담
   - 스캔된 이미지 용량이 큰 경우 업로드 불가

#### 2. 세부적인 과정 처리 방안

#### 프로세스 상세 설명

1. **사용자 이미지 업로드**
   - 웹/모바일 인터페이스를 통한 이미지 업로드
   - 이미지 포맷 검증 및 초기 품질 체크

2. **관심 영역 검출**
   - 처방전/약봉투 영역 자동 감지
   - 주요 정보 영역 분할
   - 템플릿 매칭을 통한 영역 분류

3. **OCR 처리 (PaddleOCR)**
   - 한글 텍스트 인식
   - 특수 문자 및 기호 처리
   - 텍스트 방향 자동 감지
   - 인식 신뢰도 점수 계산

4. **텍스트 전처리 & 유사도 매칭**
   - OCR 결과 정규화
   - 오타 및 오인식 보정
   - 의약품 데이터베이스와 매칭
   - 유사도 기반 최적 매칭 선택

5. **정보 검증 (회원)**
   - 추출 결과 시각화
   - 직관적인 수정 인터페이스
   - 검증 이력 관리

6. **결과 저장**
   - 정규화된 데이터 저장
   - 검증 이력 추적
   - 백업 및 복구 시스템

### 문제점 및 한계

1. **개발 복잡도**
   - 복잡한 알고리즘 구현 필요
   - 다양한 예외 상황 처리
   - 긴 개발 기간
   - 전문 인력 필요

2. **유지보수 부담**
   - 개별 모듈 관리 필요
   - 버전 관리 복잡성
   - 지속적인 성능 최적화 요구
   - 다양한 환경 대응

3. **성능 최적화**
   - 실시간 처리 속도 개선 필요
   - 리소스 사용량 최적화
   - 대용량 처리 시 병목현상
   - 서버 부하 관리
### 현재까지의 진척도
- 여러 개의 약 처방전 데이터를 통해 결과 값 비교
- ChatGPT는 약 38% 정확도를 가짐
  - 토큰 비용과 정확도가 낮아 시간이 들더라도 직접 세부적으로 처리하기로 결정
- 초기 버전은 약 22% 정확도를 가짐
  - Paddle OCR을 이용하여 단순히 데이터를 읽어오고 약물 데이터 csv파일과 비교
- 개선 버전은 약 38% 정확도를 가짐
  - 데이터를 비교할 때, 유사도 매칭에서 FastText와 Faiss를 이용하여 정확도도 개선 
